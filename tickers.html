package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/joho/godotenv"
	hyperliquid "github.com/sonirico/go-hyperliquid"
)

var info *hyperliquid.Info
var lastTradeTimestamps map[string]int64
var lastPolymarketTimestamps map[string]int64
var botStartTime int64

type PolymarketTrade struct {
	ProxyWallet     string  `json:"proxyWallet"`
	Side            string  `json:"side"`
	Asset           string  `json:"asset"`
	ConditionId     string  `json:"conditionId"`
	Size            float64 `json:"size"`
	Price           float64 `json:"price"`
	Timestamp       int64   `json:"timestamp"`
	Title           string  `json:"title"`
	Outcome         string  `json:"outcome"`
	TransactionHash string  `json:"transactionHash"`
}

func main() {
	// Load .env file
	err := godotenv.Load()
	if err != nil {
		log.Printf("Warning: .env file not found or could not be loaded: %v", err)
	}

	var asset = flag.String("asset", "", "Asset symbol (e.g., ETH) - optional for price monitoring")
	var lowerBound = flag.Float64("lower", 0, "Lower price bound")
	var upperBound = flag.Float64("upper", 0, "Upper price bound")
	flag.Parse()

	// Initialize trade tracking and record bot start time
	lastTradeTimestamps = make(map[string]int64)
	lastPolymarketTimestamps = make(map[string]int64)
	botStartTime = time.Now().UnixMilli() // Current time in milliseconds

	// Get accounts from .env file
	accountsEnv := os.Getenv("HYPERLIQUID_ACCOUNTS")
	polymarketWallet := os.Getenv("POLYMARKET_WALLET")
	
	// Validate configuration
	priceMonitoring := *asset != ""
	tradeMonitoring := accountsEnv != ""
	polymarketMonitoring := polymarketWallet != ""

	if !priceMonitoring && !tradeMonitoring && !polymarketMonitoring {
		log.Fatal("Usage: go run main.go [-asset=ETH -lower=2000 -upper=3000]\nFor trade monitoring, set HYPERLIQUID_ACCOUNTS or POLYMARKET_WALLET in .env file")
	}

	if priceMonitoring {
		if *lowerBound == 0 || *upperBound == 0 {
			log.Fatal("When monitoring prices, both -lower and -upper bounds are required")
		}
		if *lowerBound >= *upperBound {
			log.Fatal("Lower bound must be less than upper bound")
		}
		assetUpper := strings.ToUpper(*asset)
		log.Printf("Starting price monitoring for %s (%.2f - %.2f)", assetUpper, *lowerBound, *upperBound)
	}

	var accountList []string
	if tradeMonitoring {
		accountList = strings.Split(accountsEnv, ",")
		for i, addr := range accountList {
			accountList[i] = strings.TrimSpace(addr)
		}
		log.Printf("Starting Hyperliquid trade monitoring for %d accounts: %v", len(accountList), accountList)
	}

	if polymarketMonitoring {
		log.Printf("Starting Polymarket trade monitoring for wallet: %s", polymarketWallet)
	}

	info = hyperliquid.NewInfo("https://api.hyperliquid.xyz", false, nil, nil)

	// Initialize trade timestamps for each account to avoid historical alerts
	if tradeMonitoring {
		for _, account := range accountList {
			initializeAccountTradeTimestamp(account)
		}
	}

	// Initialize Polymarket trade timestamp
	if polymarketMonitoring {
		initializePolymarketTradeTimestamp(polymarketWallet)
	}

	ticker := time.NewTicker(10 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			// Price monitoring
			if priceMonitoring {
				assetUpper := strings.ToUpper(*asset)
				price, err := fetchPrice(assetUpper)
				if err != nil {
					log.Printf("Error fetching price: %v", err)
				} else {
					log.Printf("%s: %.2f (%.2f/%.2f)", assetUpper, price, *lowerBound, *upperBound)

					if price < *lowerBound {
						message := fmt.Sprintf("ðŸ”´ PRICE ALERT: %s dropped below %.2f! Current: %.2f", assetUpper, *lowerBound, price)
						sendTgMessage(message, true)
						log.Printf("Alert sent: %s", message)
					} else if price > *upperBound {
						message := fmt.Sprintf("ðŸ”´ PRICE ALERT: %s exceeded %.2f! Current: %.2f", assetUpper, *upperBound, price)
						sendTgMessage(message, true)
						log.Printf("Alert sent: %s", message)
					}
				}
			}

			// Trade monitoring
			if tradeMonitoring {
				for _, account := range accountList {
					err := checkAccountTrades(account)
					if err != nil {
						log.Printf("Error checking trades for account %s: %v", account, err)
					}
				}
			}

			// Polymarket trade monitoring
			if polymarketMonitoring {
				err := checkPolymarketTrades(polymarketWallet)
				if err != nil {
					log.Printf("Error checking Polymarket trades: %v", err)
				}
			}
		}
	}
}

func fetchPrice(asset string) (float64, error) {
	response, err := info.L2Snapshot(asset)
	if err != nil {
		return 0, fmt.Errorf("failed to get L2 snapshot: %v", err)
	}

	if len(response.Levels) > 0 && len(response.Levels[0]) > 0 {
		return response.Levels[0][0].Px, nil
	}

	return 0, fmt.Errorf("no price data available for %s", asset)
}

func checkAccountTrades(account string) error {
	trades, err := info.UserFills(account)
	if err != nil {
		return fmt.Errorf("failed to get user fills: %v", err)
	}

	if len(trades) == 0 {
		return nil
	}

	// Get the most recent trade
	latestTrade := trades[0]
	
	// Use timestamp directly (it's already int64)
	timestamp := latestTrade.Time

	// Check if this is a new trade that occurred after bot started
	lastTimestamp, exists := lastTradeTimestamps[account]
	if timestamp > botStartTime && (!exists || timestamp > lastTimestamp) {
		// New trade detected after bot start
		lastTradeTimestamps[account] = timestamp
		
		// Format trade notification (Dir field contains "Buy" or "Sell")
		side := strings.ToUpper(latestTrade.Dir)
		
		priceFloat, _ := strconv.ParseFloat(latestTrade.Price, 64)
		sizeFloat, _ := strconv.ParseFloat(latestTrade.Size, 64)
		
		message := fmt.Sprintf("ðŸ”µ TRADE ALERT: %s %.4f %s @ %.2f (Account: %s)", 
			side, sizeFloat, latestTrade.Coin, priceFloat, account[:8]+"...")
		
		sendTgMessage(message, true)
		log.Printf("Trade alert sent: %s", message)
	}

	return nil
}

func initializeAccountTradeTimestamp(account string) {
	trades, err := info.UserFills(account)
	if err != nil {
		log.Printf("Warning: Could not initialize trade timestamp for account %s: %v", account, err)
		return
	}

	if len(trades) > 0 {
		// Set the last known trade timestamp to the most recent trade
		lastTradeTimestamps[account] = trades[0].Time
		log.Printf("Initialized trade tracking for account %s (latest trade: %d)", account[:8]+"...", trades[0].Time)
	} else {
		log.Printf("No historical trades found for account %s", account[:8]+"...")
	}
}

func fetchPolymarketTrades(wallet string) ([]PolymarketTrade, error) {
	url := fmt.Sprintf("https://data-api.polymarket.com/trades?user=%s&limit=10", wallet)
	
	resp, err := http.Get(url)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch Polymarket trades: %v", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %v", err)
	}

	var trades []PolymarketTrade
	if err := json.Unmarshal(body, &trades); err != nil {
		return nil, fmt.Errorf("failed to parse trades: %v", err)
	}

	return trades, nil
}

func checkPolymarketTrades(wallet string) error {
	trades, err := fetchPolymarketTrades(wallet)
	if err != nil {
		return err
	}

	if len(trades) == 0 {
		return nil
	}

	// Get the most recent trade
	latestTrade := trades[0]
	timestamp := latestTrade.Timestamp

	// Check if this is a new trade that occurred after bot started
	lastTimestamp, exists := lastPolymarketTimestamps[wallet]
	if timestamp > botStartTime/1000 && (!exists || timestamp > lastTimestamp) {
		// New trade detected after bot start
		lastPolymarketTimestamps[wallet] = timestamp

		// Format trade notification
		side := strings.ToUpper(latestTrade.Side)
		usdValue := latestTrade.Size * latestTrade.Price

		message := fmt.Sprintf("ðŸŸ£ POLYMARKET: %s $%.2f on \"%s\" (%s @ %.2fÂ¢)",
			side, usdValue, latestTrade.Title, latestTrade.Outcome, latestTrade.Price*100)

		sendTgMessage(message, true)
		log.Printf("Polymarket alert sent: %s", message)
	}

	return nil
}

func initializePolymarketTradeTimestamp(wallet string) {
	trades, err := fetchPolymarketTrades(wallet)
	if err != nil {
		log.Printf("Warning: Could not initialize Polymarket trade timestamp: %v", err)
		return
	}

	if len(trades) > 0 {
		lastPolymarketTimestamps[wallet] = trades[0].Timestamp
		log.Printf("Initialized Polymarket tracking for wallet %s (latest trade: %d)", wallet[:8]+"...", trades[0].Timestamp)
	} else {
		log.Printf("No historical Polymarket trades found for wallet %s", wallet[:8]+"...")
	}
}
